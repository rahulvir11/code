'use client';

import React, { useRef, useEffect, useState, useCallback } from 'react';

const EmojiCatcherGame = () => {
  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysPressed = useRef(new Set()); // Move this outside of useEffect
  const [gameState, setGameState] = useState({
    score: 0,
    gameOver: false,
    paused: false
  });

  // Game objects
  const gameObjects = useRef({
    basket: { x: 400, y: 550, width: 60, height: 40, isDragging: false, dragOffset: { x: 0, y: 0 } },
    emojis: [],
    powerUps: [],
    effects: {
      magnet: { active: false, duration: 0 },
      shield: { active: false, uses: 0 },
      timeFreeze: { active: false, duration: 0 }
    },
    lastSpawn: 0,
    spawnRate: 1000,
    difficulty: 1
  });

  const regularEmojis = ['🍎', '🍊', '🍌', '🍇', '🍓', '🥝', '🍑', '🍒', '🥭', '🍍'];
  const powerUpEmojis = [
    { emoji: '🧲', type: 'magnet' },
    { emoji: '🛡️', type: 'shield' },
    { emoji: '❤️', type: 'heart' },
    { emoji: '⏰', type: 'timeFreeze' }
  ];
  const badEmojis = ['💣', '☠️', '🔥', '⚠️'];

  // Initialize canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gameObjects.current.basket.x = canvas.width / 2 - 30;
      gameObjects.current.basket.y = canvas.height - 80;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  // Game loop
  useEffect(() => {
    if (gameState.gameOver || gameState.paused) return;

    const gameLoop = () => {
      update();
      draw();
      gameLoopRef.current = requestAnimationFrame(gameLoop);
    };

    gameLoopRef.current = requestAnimationFrame(gameLoop);

    return () => {
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
    };
  }, [gameState.gameOver, gameState.paused]);

  // Keyboard controls with improved responsiveness
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (gameState.gameOver || gameState.paused) return;
      
      if (['ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keysPressed.current.add(e.key);
      }
    };

    const handleKeyUp = (e) => {
      keysPressed.current.delete(e.key);
    };

    const updateMovement = () => {
      if (gameState.gameOver || gameState.paused) return;
      
      const canvas = canvasRef.current;
      if (!canvas) return;

      const objects = gameObjects.current;
      const moveSpeed = 10; // Decreased from 35 to 20 for less sensitive movement

      if (keysPressed.current.has('ArrowLeft')) {
        objects.basket.x = Math.max(0, objects.basket.x - moveSpeed);
      }
      if (keysPressed.current.has('ArrowRight')) {
        objects.basket.x = Math.min(canvas.width - objects.basket.width, objects.basket.x + moveSpeed);
      }
    };

    // Use requestAnimationFrame for smooth movement
    const moveLoop = () => {
      updateMovement();
      requestAnimationFrame(moveLoop);
    };
    const moveLoopId = requestAnimationFrame(moveLoop);

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      cancelAnimationFrame(moveLoopId);
    };
  }, [gameState.gameOver, gameState.paused]);

  const spawnEmoji = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const now = Date.now();
    const objects = gameObjects.current;

    if (now - objects.lastSpawn > objects.spawnRate / objects.difficulty) {
      const rand = Math.random();
      let emoji;
      
      if (rand < 0.05) { // 5% chance for bad emoji
        emoji = { emoji: badEmojis[Math.floor(Math.random() * badEmojis.length)], type: 'bad' };
      } else if (rand < 0.15) { // 10% chance for power-up (adjusted range)
        emoji = powerUpEmojis[Math.floor(Math.random() * powerUpEmojis.length)];
      } else { // 85% chance for regular emoji
        emoji = { emoji: regularEmojis[Math.floor(Math.random() * regularEmojis.length)], type: 'regular' };
      }

      const newEmoji = {
        x: Math.random() * (canvas.width - 40),
        y: -40,
        width: 40,
        height: 40,
        speed: (Math.random() * 2 + 1) * objects.difficulty,
        emoji: emoji.emoji,
        type: emoji.type || 'regular',
        id: Date.now() + Math.random()
      };

      objects.emojis.push(newEmoji);
      objects.lastSpawn = now;
    }
  }, []);

  const update = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const objects = gameObjects.current;
    
    spawnEmoji();

    // Update difficulty
    objects.difficulty = 1 + gameState.score * 0.02;
    objects.spawnRate = Math.max(300, 1000 - gameState.score * 10);

    // Update power-up effects
    if (objects.effects.magnet.active) {
      objects.effects.magnet.duration -= 16;
      if (objects.effects.magnet.duration <= 0) {
        objects.effects.magnet.active = false;
      }
    }

    if (objects.effects.timeFreeze.active) {
      objects.effects.timeFreeze.duration -= 16;
      if (objects.effects.timeFreeze.duration <= 0) {
        objects.effects.timeFreeze.active = false;
      }
    }

    // Update emojis
    objects.emojis = objects.emojis.filter(emoji => {
      // Apply time freeze slowdown effect
      const speedMultiplier = objects.effects.timeFreeze.active ? 0.2 : 1.0; // Slow down to 20% speed when frozen
      emoji.y += emoji.speed * speedMultiplier;

      // Magnet effect with improved attraction
      if (objects.effects.magnet.active) {
        const dx = objects.basket.x + objects.basket.width / 2 - (emoji.x + emoji.width / 2);
        const dy = objects.basket.y + objects.basket.height / 2 - (emoji.y + emoji.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 180) { // Increased range from 150 to 180
          const magnetStrength = 1.2; // Increased from 0.8 to 1.2
          emoji.x += dx * magnetStrength * 0.2; // Increased from 0.15 to 0.2
          emoji.y += dy * magnetStrength * 0.2; // Increased from 0.15 to 0.2
        }
      }

      // Collision detection
      if (emoji.x < objects.basket.x + objects.basket.width &&
          emoji.x + emoji.width > objects.basket.x &&
          emoji.y < objects.basket.y + objects.basket.height &&
          emoji.y + emoji.height > objects.basket.y) {
        
        if (emoji.type === 'regular') {
          setGameState(prev => ({ ...prev, score: prev.score + 10 }));
        } else if (emoji.type === 'bad') {
          // Bad emoji caught - game over immediately
          setGameState(prev => ({ ...prev, gameOver: true }));
        } else {
          applyPowerUp(emoji.type);
        }
        return false;
      }

      // Remove if off screen
      if (emoji.y > canvas.height) {
        // Only bad emojis cause game over when caught, not when missed
        // Regular emojis and power-ups don't cause any penalty when missed
        return false;
      }

      return true;
    });
  }, [gameState.score, spawnEmoji]);

  const applyPowerUp = useCallback((type) => {
    const objects = gameObjects.current;
    
    switch (type) {
      case 'magnet':
        objects.effects.magnet.active = true;
        objects.effects.magnet.duration = 5000; // Increased from 3000 to 5000ms (5 seconds)
        break;
      case 'shield':
        objects.effects.shield.active = true;
        objects.effects.shield.uses = 1;
        break;
      case 'heart':
        // Heart power-up no longer needed since there are no lives
        // But we can keep it for bonus points instead
        setGameState(prev => ({ 
          ...prev, 
          score: prev.score + 50 // Bonus points instead of extra life
        }));
        break;
      case 'timeFreeze':
        objects.effects.timeFreeze.active = true;
        objects.effects.timeFreeze.duration = 4000; // Increased from 3000 to 4000ms (4 seconds)
        break;
    }
  }, []);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw simple animated background
    drawSimpleBackground(ctx, canvas);

    const objects = gameObjects.current;
    const time = Date.now();

    // Draw emojis with enhanced effects
    ctx.font = '32px Arial';
    objects.emojis.forEach(emoji => {
      const baseX = emoji.x;
      const baseY = emoji.y + emoji.height;
      
      if (emoji.type === 'bad') {
        // Pulsating red glow for bad emojis
        const pulseIntensity = 0.5 + 0.5 * Math.sin(time * 0.008);
        ctx.shadowColor = `rgba(255, 0, 0, ${pulseIntensity})`;
        ctx.shadowBlur = 20 + 10 * pulseIntensity;
        
        // Add slight shake effect
        const shakeX = Math.sin(time * 0.02) * 2;
        const shakeY = Math.cos(time * 0.03) * 1;
        ctx.fillText(emoji.emoji, baseX + shakeX, baseY + shakeY);
        
      } else if (emoji.type === 'magnet') {
        // Purple/pink glow for magnet
        const pulseIntensity = 0.6 + 0.4 * Math.sin(time * 0.01);
        ctx.shadowColor = `rgba(255, 0, 255, ${pulseIntensity})`;
        ctx.shadowBlur = 15 + 8 * pulseIntensity;
        
        // Floating animation
        const floatY = Math.sin(time * 0.005 + emoji.id) * 3;
        ctx.fillText(emoji.emoji, baseX, baseY + floatY);
        
      } else if (emoji.type === 'shield') {
        // Blue glow for shield
        const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 0.006);
        ctx.shadowColor = `rgba(0, 150, 255, ${pulseIntensity})`;
        ctx.shadowBlur = 18 + 7 * pulseIntensity;
        
        // Gentle rotation effect
        ctx.save();
        ctx.translate(baseX + 16, baseY - 16);
        ctx.rotate(Math.sin(time * 0.003) * 0.1);
        ctx.fillText(emoji.emoji, -16, 16);
        ctx.restore();
        
      } else if (emoji.type === 'heart') {
        // Pink/red glow for heart
        const pulseIntensity = 0.8 + 0.2 * Math.sin(time * 0.012);
        ctx.shadowColor = `rgba(255, 100, 150, ${pulseIntensity})`;
        ctx.shadowBlur = 16 + 6 * pulseIntensity;
        
        // Heart beat scale effect
        const scale = 1 + 0.1 * Math.sin(time * 0.008);
        ctx.save();
        ctx.translate(baseX + 16, baseY - 16);
        ctx.scale(scale, scale);
        ctx.fillText(emoji.emoji, -16, 16);
        ctx.restore();
        
      } else if (emoji.type === 'timeFreeze') {
        // Cyan glow for time freeze
        const pulseIntensity = 0.6 + 0.4 * Math.sin(time * 0.015);
        ctx.shadowColor = `rgba(0, 255, 255, ${pulseIntensity})`;
        ctx.shadowBlur = 20 + 10 * pulseIntensity;
        
        // Spinning effect
        ctx.save();
        ctx.translate(baseX + 16, baseY - 16);
        ctx.rotate(time * 0.002);
        ctx.fillText(emoji.emoji, -16, 16);
        ctx.restore();
        
      } else {
        // Regular emojis with subtle glow
        ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
        ctx.shadowBlur = 5;
        ctx.fillText(emoji.emoji, baseX, baseY);
      }
    });
    
    // Reset shadow for other elements
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;

    // Draw basket with glow effect
    ctx.font = '48px Arial';
    ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
    ctx.shadowBlur = 8;
    
    // Add basket hover glow when dragging
    if (objects.basket.isDragging) {
      ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
      ctx.shadowBlur = 10;
    }
    
    ctx.fillText('🧺', objects.basket.x, objects.basket.y + objects.basket.height);

    // Draw draggable area indicator with modern styling
    if (objects.basket.isDragging) {
      const pulseIntensity = 0.5 + 0.5 * Math.sin(time * 0.01);
      ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + 0.3 * pulseIntensity})`;
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(
        objects.basket.x + objects.basket.width / 2,
        objects.basket.y + objects.basket.height / 2,
        100 + 10 * pulseIntensity,
        0,
        2 * Math.PI
      );
      ctx.stroke();
      ctx.setLineDash([]); // Reset line dash
    }

    // Draw UI
    drawUI(ctx, canvas);

    // Draw power-up effects
    drawEffects(ctx, canvas);
  }, [gameState]);

  const drawUI = useCallback((ctx, canvas) => {
    const time = Date.now();
    
    // Modern UI with enhanced styling
    ctx.fillStyle = 'white';
    ctx.font = 'bold 24px Arial';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.lineWidth = 3;

    // Score with glow effect
    const scoreText = `Score: ${gameState.score}`;
    ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
    ctx.shadowBlur = 8;
    ctx.strokeText(scoreText, 20, 40);
    ctx.fillText(scoreText, 20, 40);

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;

    // Controls instruction with modern styling
    ctx.font = 'bold 16px Arial';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.lineWidth = 2;
    const controlsText = 'Use ← → arrows or drag to move basket';
    ctx.strokeText(controlsText, canvas.width - 350, 30);
    ctx.fillText(controlsText, canvas.width - 350, 30);

    // Game instruction
    const instructionText = 'Catch fruits & power-ups, avoid bad emojis!';
    ctx.strokeText(instructionText, canvas.width - 350, 50);
    ctx.fillText(instructionText, canvas.width - 350, 50);

    // Power-up indicators with glow effects
    ctx.font = 'bold 24px Arial';
    let yOffset = 80;
    const objects = gameObjects.current;

    if (objects.effects.magnet.active) {
      const pulseIntensity = 0.6 + 0.4 * Math.sin(time * 0.01);
      ctx.shadowColor = `rgba(255, 0, 255, ${pulseIntensity})`;
      ctx.shadowBlur = 12;
      const magnetText = `🧲 ${Math.ceil(objects.effects.magnet.duration / 1000)}s`;
      ctx.strokeText(magnetText, 20, yOffset);
      ctx.fillText(magnetText, 20, yOffset);
      yOffset += 40;
    }

    if (objects.effects.shield.active) {
      const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 0.008);
      ctx.shadowColor = `rgba(0, 150, 255, ${pulseIntensity})`;
      ctx.shadowBlur = 10;
      const shieldText = `🛡️ ${objects.effects.shield.uses}`;
      ctx.strokeText(shieldText, 20, yOffset);
      ctx.fillText(shieldText, 20, yOffset);
      yOffset += 40;
    }

    if (objects.effects.timeFreeze.active) {
      const pulseIntensity = 0.6 + 0.4 * Math.sin(time * 0.012);
      ctx.shadowColor = `rgba(0, 255, 255, ${pulseIntensity})`;
      ctx.shadowBlur = 14;
      const freezeText = `⏰ ${Math.ceil(objects.effects.timeFreeze.duration / 1000)}s`;
      ctx.strokeText(freezeText, 20, yOffset);
      ctx.fillText(freezeText, 20, yOffset);
    }
    
    // Reset shadow for other elements
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
  }, [gameState]);

  const drawEffects = useCallback((ctx, canvas) => {
    const objects = gameObjects.current;
    const time = Date.now();

    // Magnet effect visualization with animated glow
    if (objects.effects.magnet.active) {
      const pulseIntensity = 0.6 + 0.4 * Math.sin(time * 0.008);
      const radius = 180 + 20 * Math.sin(time * 0.005); // Increased base radius from 150 to 180
      
      // Outer glow ring
      ctx.strokeStyle = `rgba(255, 0, 255, ${0.4 * pulseIntensity})`;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(
        objects.basket.x + objects.basket.width / 2,
        objects.basket.y + objects.basket.height / 2,
        radius,
        0,
        2 * Math.PI
      );
      ctx.stroke();
      
      // Inner glow ring
      ctx.strokeStyle = `rgba(255, 100, 255, ${0.6 * pulseIntensity})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(
        objects.basket.x + objects.basket.width / 2,
        objects.basket.y + objects.basket.height / 2,
        radius - 15,
        0,
        2 * Math.PI
      );
      ctx.stroke();
      
      // Magnetic field lines
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI / 4) + (time * 0.001);
        const startRadius = radius - 30;
        const endRadius = radius + 10;
        const startX = objects.basket.x + objects.basket.width / 2 + Math.cos(angle) * startRadius;
        const startY = objects.basket.y + objects.basket.height / 2 + Math.sin(angle) * startRadius;
        const endX = objects.basket.x + objects.basket.width / 2 + Math.cos(angle) * endRadius;
        const endY = objects.basket.y + objects.basket.height / 2 + Math.sin(angle) * endRadius;
        
        ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 * pulseIntensity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }
    }

    // Shield effect visualization
    if (objects.effects.shield.active) {
      const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 0.01);
      ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 * pulseIntensity})`;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(
        objects.basket.x + objects.basket.width / 2,
        objects.basket.y + objects.basket.height / 2,
        80 + 5 * pulseIntensity,
        0,
        2 * Math.PI
      );
      ctx.stroke();
    }

    // Time freeze effect with animated overlay
    if (objects.effects.timeFreeze.active) {
      const intensity = 0.2 + 0.1 * Math.sin(time * 0.01);
      ctx.fillStyle = `rgba(173, 216, 230, ${intensity})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add frozen particles effect
      for (let i = 0; i < 50; i++) {
        const x = (i * 137.5) % canvas.width; // Golden ratio for even distribution
        const y = (i * 234.7 + time * 0.05) % canvas.height;
        const opacity = 0.3 + 0.2 * Math.sin(time * 0.003 + i);
        
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }, []);

  // Simple animated background function
  const drawSimpleBackground = useCallback((ctx, canvas) => {
    const time = Date.now() * 0.001; // Convert to seconds for smoother animation
    
    // Create simple animated gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    
    // Simple color animation - cycling through pleasant colors
    const hue = (time * 20) % 360; // Slower color transition
    gradient.addColorStop(0, `hsl(${hue}, 40%, 90%)`);
    gradient.addColorStop(0.5, `hsl(${hue + 30}, 50%, 85%)`);
    gradient.addColorStop(1, `hsl(${hue + 60}, 45%, 80%)`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add simple floating circles
    ctx.globalAlpha = 0.1;
    for (let i = 0; i < 20; i++) {
      const x = (i * 150 + time * 30) % (canvas.width + 100) - 50;
      const y = canvas.height * 0.3 + Math.sin(time * 0.5 + i) * 100;
      const size = 20 + (i % 3) * 10;
      
      ctx.fillStyle = `hsl(${hue + i * 20}, 60%, 70%)`;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, 2 * Math.PI);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }, []);

  // Mouse/Touch event handlers
  const handlePointerDown = useCallback((e) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const objects = gameObjects.current;
    
    // Check if click/touch is anywhere near the basket area (expanded hitbox)
    const basketCenterX = objects.basket.x + objects.basket.width / 2;
    const basketCenterY = objects.basket.y + objects.basket.height / 2;
    const expandedHitbox = 100; // Larger area around basket for easier dragging
    
    if (Math.abs(x - basketCenterX) <= expandedHitbox && 
        Math.abs(y - basketCenterY) <= expandedHitbox) {
      objects.basket.isDragging = true;
      objects.basket.dragOffset = {
        x: x - objects.basket.x,
        y: y - objects.basket.y
      };
      e.preventDefault();
    }
  }, []);

  const handlePointerMove = useCallback((e) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const objects = gameObjects.current;
    if (!objects.basket.isDragging) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;

    objects.basket.x = Math.max(0, Math.min(canvas.width - objects.basket.width, x - objects.basket.dragOffset.x));
    e.preventDefault();
  }, []);

  const handlePointerUp = useCallback(() => {
    gameObjects.current.basket.isDragging = false;
  }, []);

  const resetGame = useCallback(() => {
    gameObjects.current = {
      basket: { 
        x: canvasRef.current?.width / 2 - 30 || 400, 
        y: canvasRef.current?.height - 80 || 550, 
        width: 60, 
        height: 40, 
        isDragging: false, 
        dragOffset: { x: 0, y: 0 } 
      },
      emojis: [],
      powerUps: [],
      effects: {
        magnet: { active: false, duration: 0 },
        shield: { active: false, uses: 0 },
        timeFreeze: { active: false, duration: 0 }
      },
      lastSpawn: 0,
      spawnRate: 1000,
      difficulty: 1
    };
    setGameState({
      score: 0,
      gameOver: false,
      paused: false
    });
  }, []);

  return (
    <div style={{ position: 'relative', width: '100vw', height: '100vh', overflow: 'hidden' }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          cursor: gameObjects.current.basket.isDragging ? 'grabbing' : 'grab',
          touchAction: 'none'
        }}
        onMouseDown={handlePointerDown}
        onMouseMove={handlePointerMove}
        onMouseUp={handlePointerUp}
        onMouseLeave={handlePointerUp}
        onTouchStart={handlePointerDown}
        onTouchMove={handlePointerMove}
        onTouchEnd={handlePointerUp}
      />
      
      {gameState.gameOver && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9))',
          color: 'white',
          padding: '30px',
          borderRadius: '20px',
          textAlign: 'center',
          fontSize: '24px',
          boxShadow: '0 20px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(255, 255, 255, 0.1)',
          border: '2px solid rgba(255, 255, 255, 0.2)',
          backdropFilter: 'blur(10px)'
        }}>
          <div style={{ 
            marginBottom: '15px',
            textShadow: '0 0 10px rgba(255, 100, 100, 0.8)'
          }}>🎮 Game Over! 🎮</div>
          <div style={{ 
            fontSize: '28px',
            color: '#FFD700',
            textShadow: '0 0 15px rgba(255, 215, 0, 0.8)',
            marginBottom: '20px'
          }}>Final Score: {gameState.score}</div>
          <button
            onClick={resetGame}
            style={{
              marginTop: '10px',
              padding: '15px 30px',
              fontSize: '18px',
              background: 'linear-gradient(135deg, #4CAF50, #45A049)',
              color: 'white',
              border: 'none',
              borderRadius: '25px',
              cursor: 'pointer',
              boxShadow: '0 5px 15px rgba(76, 175, 80, 0.4)',
              transition: 'all 0.3s ease',
              textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)'
            }}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
              e.target.style.boxShadow = '0 8px 25px rgba(76, 175, 80, 0.6)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
              e.target.style.boxShadow = '0 5px 15px rgba(76, 175, 80, 0.4)';
            }}
          >
            🎯 Play Again
          </button>
        </div>
      )}
    </div>
  );
};

export default EmojiCatcherGame;
